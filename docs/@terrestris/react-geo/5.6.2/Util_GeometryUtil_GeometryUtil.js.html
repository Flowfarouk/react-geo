<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: Util/GeometryUtil/GeometryUtil.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: Util/GeometryUtil/GeometryUtil.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>import OlFeature from 'ol/feature';
import OlGeomMultiPolygon from 'ol/geom/multipolygon';
import OlGeomMultiPoint from 'ol/geom/multipoint';
import OlGeomMultiLineString from 'ol/geom/multilinestring';
import OlFormatGeoJSON from 'ol/format/geojson';

import {
  booleanPointInPolygon,
  buffer,
  centroid,
  difference,
  getCoords,
  intersect,
  multiLineString,
  polygonize,
  polygonToLine,
  segmentEach,
  union
} from '@turf/turf';

/**
 * Helper Class for the geospatial analysis.
 *
 * @class GeometryUtil
 */
class GeometryUtil {

  /**
   * The prefix used to detect multi geometries.
   */
  static MULTI_GEOM_PREFIX = 'Multi';

  /**
   * Splits an ol.feature with/or ol.geom.Polygon by an ol.feature with/or ol.geom.LineString
   * into an array of instances of ol.feature with/or ol.geom.Polygon.
   * If the target polygon (first param) is of type ol.Feature it will return an
   * array with ol.Feature. If the target polygon (first param) is of type
   * ol.geom.Geometry it will return an array with ol.geom.Geometry.
   *
   * @param {ol.feature | ol.geom.Polygon} polygon The polygon geometry to split.
   * @param {ol.feature | ol.geom.LineString} lineFeat The line geometry to split the polygon
   *  geometry with.
   * @param {ol.ProjectionLike} projection The EPSG code of the input features.
   *  Default is to EPSG:3857.
   * @param {Number} tolerance The tolerance (in meters) used to find if a line
   *  vertex is inside the polygon geometry. Default is to 10.
   *
   * @returns {ol.Feature[] | ol.geom.Polygon[]} An array of instances of ol.feature
   *  with/or ol.geom.Polygon
   */
  static splitByLine(polygon, line, projection = 'EPSG:3857', tolerance = 10) {
    const geoJsonFormat = new OlFormatGeoJSON({
      dataProjection: 'EPSG:4326',
      featureProjection: projection
    });
    const polygonFeat = polygon instanceof OlFeature ? polygon
      : new OlFeature({
        geometry: polygon
      });
    const lineFeat = line instanceof OlFeature ? line
      : new OlFeature({
        geometry: line
      });

    // Convert the input features to turf.js/GeoJSON features while
    // reprojecting them to the internal turf.js projection 'EPSG:4326'.
    const turfPolygon = geoJsonFormat.writeFeatureObject(polygonFeat);
    const turfLine = geoJsonFormat.writeFeatureObject(lineFeat);

    // Union both geometries to a set of MultiLineStrings.
    const unionGeom = union(polygonToLine(turfPolygon), turfLine);

    // Buffer the input polygon to take great circle (un-)precision
    // into account.
    const bufferedTurfPolygon = buffer(turfPolygon, tolerance, {
      units: 'meters'
    });

    let filteredSegments = [];

    // Iterate over each segment and remove any segment that is not covered by
    // the (buffered) input polygon.
    segmentEach(unionGeom, (currentSegment, featureIndex, multiFeatureIndex) => {
      const segmentCenter = centroid(currentSegment);
      const isSegmentInPolygon = booleanPointInPolygon(segmentCenter, bufferedTurfPolygon);

      if (isSegmentInPolygon) {
        if (!filteredSegments[multiFeatureIndex]) {
          filteredSegments[multiFeatureIndex] = [];
        }

        if (filteredSegments[multiFeatureIndex].length === 0) {
          filteredSegments[multiFeatureIndex].push(
            getCoords(currentSegment)[0],
            getCoords(currentSegment)[1]
          );
        } else {
          filteredSegments[multiFeatureIndex].push(
            getCoords(currentSegment)[1]
          );
        }
      }
    });

    // Rebuild the unioned geometry based in the filtered segments.
    const filteredUnionGeom = multiLineString(filteredSegments);

    // Polygonize the lines.
    const polygonizedUnionGeom = polygonize(filteredUnionGeom);

    // Return as Array of ol.Feature or ol.geom.Geometry.
    const features = geoJsonFormat.readFeatures(polygonizedUnionGeom);
    if (polygon instanceof OlFeature) {
      return features;
    } else {
      return features.map(f => f.getGeometry());
    }
  }

  /**
   * Adds a buffer to a given geometry.
   * If the target is of type ol.Feature it will return an ol.Feature.
   * If the target is of type ol.geom.Geometry it will return ol.geom.Geometry.
   *
   * @param {ol.geom.Geometry | ol.Feature} geometry The geometry.
   * @param {Number} buffer The buffer to add in meters.
   * @param {String} projection The projection of the input geometry as EPSG code.
   *  Default is to EPSG:3857.
   *
   * @returns {ol.geom.Geometry | ol.Feature} The geometry or feature with the added buffer.
   */
  static addBuffer (geometry, radius = 0, projection = 'EPSG:3857') {
    if (radius === 0) {
      return geometry;
    }
    const geoJsonFormat = new OlFormatGeoJSON({
      dataProjection: 'EPSG:4326',
      featureProjection: projection
    });
    const geoJson = geometry instanceof OlFeature
      ? geoJsonFormat.writeFeatureObject(geometry)
      : geoJsonFormat.writeGeometryObject(geometry);
    const buffered = buffer(geoJson, radius, {
      units: 'meters'
    });
    if (geometry instanceof OlFeature) {
      return geoJsonFormat.readFeature(buffered);
    } else {
      return geoJsonFormat.readGeometry(buffered.geometry);
    }
  }

  /**
   * Merges multiple geometries into one MultiGeometry.
   *
   * @param {ol.geom.Geometry[]} geometries An array of ol.geom.geometries;
   * @returns {ol.geom.Multipoint|ol.geom.MultiPolygon|ol.geom.MultiLinestring} A Multigeometry.
   */
  static mergeGeometries(geometries) {
    let geomType = geometries[0].getType();
    let mixedGeometryTypes = false;
    geometries.forEach(geometry => {
      if (geomType.replace('Multi', '') !== geometry.getType().replace('Multi', '')) {
        mixedGeometryTypes = true;
      }
    });
    if (mixedGeometryTypes) {
      // Logger.warn('Can not merge mixed geometries into one multigeometry.');
      return undefined;
    }

    // split all multi-geometries to simple ones if passed geometries are
    // multigeometries
    if (geomType.startsWith(GeometryUtil.MULTI_GEOM_PREFIX)) {
      const multiGeomPartType = geomType.substring(GeometryUtil.MULTI_GEOM_PREFIX.length);
      geometries = GeometryUtil.separateGeometries(geometries);
      geomType = multiGeomPartType;
    }

    let multiGeom;
    let append;
    switch (geomType) {
      case 'Polygon':
        multiGeom = new OlGeomMultiPolygon();
        append = multiGeom.appendPolygon.bind(multiGeom);
        break;
      case 'Point':
        multiGeom = new OlGeomMultiPoint();
        append = multiGeom.appendPoint.bind(multiGeom);
        break;
      case 'LineString':
        multiGeom = new OlGeomMultiLineString();
        append = multiGeom.appendLineString.bind(multiGeom);
        break;
      default:
        return undefined;
    }
    geometries.forEach(geom => append(geom));
    return multiGeom;
  }

  /**
   * Splits an array of geometries (and multi geometries) or a single MultiGeom
   * into an array of single geometries.
   *
   * Attention: ol.geom.Circle and ol.geom.LinearRing are not supported.
   *
   * @param {ol.geom.SimpleGeometry|ol.geom.SimpleGeometry[]} geometries An (array of) ol.geom.geometries;
   * @returns {ol.geom.Point[]|ol.geom.Polygon[]|ol.geom.LineString[]} An array of geometries.
   */
  static separateGeometries(geometries) {
    const separatedGeometries = [];

    geometries = Array.isArray(geometries) ? geometries : [geometries];

    geometries.forEach(geometry => {
      const geomType = geometry.getType();
      if (geomType.startsWith(GeometryUtil.MULTI_GEOM_PREFIX)) {
        const multiGeomPartType = geomType.substring(GeometryUtil.MULTI_GEOM_PREFIX.length);
        switch (multiGeomPartType) {
          case 'Polygon':
            separatedGeometries.push(...geometry.getPolygons());
            break;
          case 'LineString':
            separatedGeometries.push(...geometry.getLineStrings());
            break;
          case 'Point':
            separatedGeometries.push(...geometry.getPoints());
            break;
          default:
            break;
        }
      } else {
        separatedGeometries.push(geometry);
      }
    });
    return separatedGeometries;
  }

  /**
   * Takes two or more polygons and returns a combined polygon.
   *
   * @param {ol.geom.Geometry[] | ol.Feature[]} polygons An array of ol.Feature
   *  or ol.geom.Geometry instances of type polygon.
   * @param {String} projection The projection of the input polygons as EPSG code.
   *  Default is to EPSG:3857.
   * @returns {ol.geom.Geometry | ol.Feature} A Feature or Geometry with the
   * combined area of the polygons.
   */
  static union(polygons, projection = 'EPSG:3857') {
    const geoJsonFormat = new OlFormatGeoJSON({
      dataProjection: 'EPSG:4326',
      featureProjection: projection
    });
    let invalid = false;
    const geoJsonsFeatures = polygons.map((geometry) => {
      const feature = geometry instanceof OlFeature
        ? geometry
        : new OlFeature({geometry});
      if (feature.getGeometry().getType() !== 'Polygon') {
        invalid = true;
      }
      return geoJsonFormat.writeFeatureObject(feature);
    });
    if (invalid) {
      // Logger.warn('Can only create union of polygons.');
      return undefined;
    }
    const unioned = union(...geoJsonsFeatures);
    const feature = geoJsonFormat.readFeature(unioned);
    if (polygons[0] instanceof OlFeature) {
      return feature;
    } else {
      return feature.getGeometry();
    }
  }

  /**
   * Finds the difference between two polygons by clipping the second polygon from the first.
   *
   * @param {ol.geom.Geometry | ol.Feature} feature An ol.geom.Geoemtry or ol.Feature
   * @param {ol.geom.Geometry | ol.Feature} feature An ol.geom.Geoemtry or ol.Feature
   * @param {String} projection The projection of the input polygons as EPSG code.
   *  Default is to EPSG:3857.
   *
   * @returns {ol.geom.Geometry | ol.Feature} A Feature or Geometry with the area
   *  of polygon1 excluding the area of polygon2.
   */
  static difference(polygon1, polygon2, projection = 'EPSG:3857') {
    const geoJsonFormat = new OlFormatGeoJSON({
      dataProjection: 'EPSG:4326',
      featureProjection: projection
    });
    const feat1 = polygon1 instanceof OlFeature ? polygon1
      : new OlFeature({
        geometry: polygon1
      });
    const feat2 = polygon2 instanceof OlFeature ? polygon2
      : new OlFeature({
        geometry: polygon2
      });
    const geojson1 = geoJsonFormat.writeFeatureObject(feat1);
    const geojson2 = geoJsonFormat.writeFeatureObject(feat2);
    const intersection = difference(geojson1, geojson2);
    const feature = geoJsonFormat.readFeature(intersection);
    if (polygon1 instanceof OlFeature &amp;&amp; polygon2 instanceof OlFeature) {
      return feature;
    } else {
      return feature.getGeometry();
    }
  }

  /**
   * Takes two polygons and finds their intersection.
   * If the polygons are of type ol.Feature it will return an ol.Feature.
   * If the polygons are of type ol.geom.Geometry it will return an ol.geom.Geometry.
   *
   * @param {ol.geom.Geometry | ol.Feature} polygon1 An ol.geom.Geoemtry or ol.Feature
   * @param {ol.geom.Geometry | ol.Feature} polygon2 An ol.geom.Geoemtry or ol.Feature
   * @param {String} projection The projection of the input polygons as EPSG code.
   *  Default is to EPSG:3857.
   *
   * @returns {ol.geom.Geometry | ol.Feature} A Feature or Geometry with the
   * shared area of the two polygons or null if the polygons don't intersect.
   */
  static intersection(polygon1, polygon2, projection = 'EPSG:3857') {
    const geoJsonFormat = new OlFormatGeoJSON({
      dataProjection: 'EPSG:4326',
      featureProjection: projection
    });
    const feat1 = polygon1 instanceof OlFeature ? polygon1
      : new OlFeature({
        geometry: polygon1
      });
    const feat2 = polygon2 instanceof OlFeature ? polygon2
      : new OlFeature({
        geometry: polygon2
      });
    const geojson1 = geoJsonFormat.writeFeatureObject(feat1);
    const geojson2 = geoJsonFormat.writeFeatureObject(feat2);
    const intersection = intersect(geojson1, geojson2);
    if (!intersection) {
      return null;
    }
    const feature = geoJsonFormat.readFeature(intersection);
    if (polygon1 instanceof OlFeature &amp;&amp; polygon2 instanceof OlFeature) {
      return feature;
    } else {
      return feature.getGeometry();
    }
  }

}

export default GeometryUtil;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="AddWmsLayerEntry.html">AddWmsLayerEntry</a></li><li><a href="AddWmsPanel.html">AddWmsPanel</a></li><li><a href="AnimateUtil.html">AnimateUtil</a></li><li><a href="CapabilitiesUtil.html">CapabilitiesUtil</a></li><li><a href="CircleMenu.html">CircleMenu</a></li><li><a href="CircleMenuItem.html">CircleMenuItem</a></li><li><a href="CoordinateReferenceSystemCombo.html">CoordinateReferenceSystemCombo</a></li><li><a href="CsrfUtil.html">CsrfUtil</a></li><li><a href="DigitizeButton.html">DigitizeButton</a></li><li><a href="FeatureGrid.html">FeatureGrid</a></li><li><a href="FeatureUtil.html">FeatureUtil</a></li><li><a href="FloatingMapLogo.html">FloatingMapLogo</a></li><li><a href="GeoLocationButton.html">GeoLocationButton</a></li><li><a href="GeometryUtil.html">GeometryUtil</a></li><li><a href="LayerTransparencySlider.html">LayerTransparencySlider</a></li><li><a href="LayerTree.html">LayerTree</a></li><li><a href="LayerTreeNode.html">LayerTreeNode</a></li><li><a href="Legend.html">Legend</a></li><li><a href="MapComponent.html">MapComponent</a></li><li><a href="MappifiedComponent.html">MappifiedComponent</a></li><li><a href="MapProvider.html">MapProvider</a></li><li><a href="MapUtil.html">MapUtil</a></li><li><a href="MathUtil.html">MathUtil</a></li><li><a href="MeasureButton.html">MeasureButton</a></li><li><a href="MeasureUtil.html">MeasureUtil</a></li><li><a href="MultiLayerSlider.html">MultiLayerSlider</a></li><li><a href="NominatimSearch.html">NominatimSearch</a></li><li><a href="ObjectUtil.html">ObjectUtil</a></li><li><a href="Panel.html">Panel</a></li><li><a href="ProjectionUtil.html">ProjectionUtil</a></li><li><a href="PropertyGrid.html">PropertyGrid</a></li><li><a href="ScaleCombo.html">ScaleCombo</a></li><li><a href="SimpleButton.html">SimpleButton</a></li><li><a href="StringUtil.html">StringUtil</a></li><li><a href="TestUtil.html">TestUtil</a></li><li><a href="TimeSlider.html">TimeSlider</a></li><li><a href="Titlebar.html">Titlebar</a></li><li><a href="ToggleButton.html">ToggleButton</a></li><li><a href="ToggleGroup.html">ToggleGroup</a></li><li><a href="Toolbar.html">Toolbar</a></li><li><a href="UndoUtil.html">UndoUtil</a></li><li><a href="UploadButton.html">UploadButton</a></li><li><a href="UrlUtil.html">UrlUtil</a></li><li><a href="UserChip.html">UserChip</a></li><li><a href="VisibleComponent.html">VisibleComponent</a></li><li><a href="Window.html">Window</a></li><li><a href="ZoomInButton.html">ZoomInButton</a></li><li><a href="ZoomOutButton.html">ZoomOutButton</a></li><li><a href="ZoomToExtentButton.html">ZoomToExtentButton</a></li></ul><h3>Global</h3><ul><li><a href="global.html#absolutelyPostioned">absolutelyPostioned</a></li><li><a href="global.html#addAllLayersText">addAllLayersText</a></li><li><a href="global.html#addressdetails">addressdetails</a></li><li><a href="global.html#addSelectedLayersText">addSelectedLayersText</a></li><li><a href="global.html#alignment">alignment</a></li><li><a href="global.html#allowDeselect">allowDeselect</a></li><li><a href="global.html#animate">animate</a></li><li><a href="global.html#animateOptions">animateOptions</a></li><li><a href="global.html#animationDuration">animationDuration</a></li><li><a href="global.html#attributeBlacklist">attributeBlacklist</a></li><li><a href="global.html#attributeFilter">attributeFilter</a></li><li><a href="global.html#attributeNameColumnTitle">attributeNameColumnTitle</a></li><li><a href="global.html#attributeNameColumnWidthInPercent">attributeNameColumnWidthInPercent</a></li><li><a href="global.html#attributeNames">attributeNames</a></li><li><a href="global.html#attributeValueColumnTitle">attributeValueColumnTitle</a></li><li><a href="global.html#bounded">bounded</a></li><li><a href="global.html#buttonCoords">buttonCoords</a></li><li><a href="global.html#cancelText">cancelText</a></li><li><a href="global.html#children">children</a></li><li><a href="global.html#className">className</a></li><li><a href="global.html#clearDrawFeatures">clearDrawFeatures</a></li><li><a href="global.html#clearOperationFeatures">clearOperationFeatures</a></li><li><a href="global.html#clickToDrawText">clickToDrawText</a></li><li><a href="global.html#closable">closable</a></li><li><a href="global.html#collapseTooltip">collapseTooltip</a></li><li><a href="global.html#collapsible">collapsible</a></li><li><a href="global.html#columnDefs">columnDefs</a></li><li><a href="global.html#componentDidMount">componentDidMount</a></li><li><a href="global.html#continueAngleMsg">continueAngleMsg</a></li><li><a href="global.html#continueLineMsg">continueLineMsg</a></li><li><a href="global.html#continuePolygonMsg">continuePolygonMsg</a></li><li><a href="global.html#countrycodes">countrycodes</a></li><li><a href="global.html#crsApiUrl">crsApiUrl</a></li><li><a href="global.html#decimalPlacesInTooltips">decimalPlacesInTooltips</a></li><li><a href="global.html#defaultValue">defaultValue</a></li><li><a href="global.html#diameter">diameter</a></li><li><a href="global.html#digitizeLayerName">digitizeLayerName</a></li><li><a href="global.html#dispatch">dispatch</a></li><li><a href="global.html#doRender">doRender</a></li><li><a href="global.html#draggable">draggable</a></li><li><a href="global.html#drawType">drawType</a></li><li><a href="global.html#editType">editType</a></li><li><a href="global.html#emptyTextPlaceholderText">emptyTextPlaceholderText</a></li><li><a href="global.html#extent">extent</a></li><li><a href="global.html#extraParams">extraParams</a></li><li><a href="global.html#feature">feature</a></li><li><a href="global.html#features">features</a></li><li><a href="global.html#featureStyle">featureStyle</a></li><li><a href="global.html#fillColor">fillColor</a></li><li><a href="global.html#filterFunction">filterFunction</a></li><li><a href="global.html#fitOptions">fitOptions</a></li><li><a href="global.html#follow">follow</a></li><li><a href="global.html#fontIcon">fontIcon</a></li><li><a href="global.html#format">format</a></li><li><a href="global.html#formatString">formatString</a></li><li><a href="global.html#getInitials">getInitials</a></li><li><a href="global.html#getOptionsFromMap:Helperfunctiongenerate%257B@linkOption%257Dscalecomponentsbasedonanexistinginstanceof%257B@linkOl.Map%257D">getOptionsFromMap: Helper function generate {@link Option} scale components
based on an existing instance of {@link Ol.Map}</a></li><li><a href="global.html#height">height</a></li><li><a href="global.html#highlightStyle">highlightStyle</a></li><li><a href="global.html#icon">icon</a></li><li><a href="global.html#id">id</a></li><li><a href="global.html#imageHeight">imageHeight</a></li><li><a href="global.html#imageSrc">imageSrc</a></li><li><a href="global.html#inputProps">inputProps</a></li><li><a href="global.html#isVisibleComponent">isVisibleComponent</a></li><li><a href="global.html#keyFunction">keyFunction</a></li><li><a href="global.html#layer">layer</a></li><li><a href="global.html#layerName">layerName</a></li><li><a href="global.html#layerQueryableText">layerQueryableText</a></li><li><a href="global.html#layers">layers</a></li><li><a href="global.html#layerTextTemplateFn">layerTextTemplateFn</a></li><li><a href="global.html#limit">limit</a></li><li><a href="global.html#map">map</a></li><li><a href="global.html#mappify">mappify</a></li><li><a href="global.html#mapPromise">mapPromise</a></li><li><a href="global.html#max">max</a></li><li><a href="global.html#measureLayerName">measureLayerName</a></li><li><a href="global.html#measureTooltipCssClasses">measureTooltipCssClasses</a></li><li><a href="global.html#measureType">measureType</a></li><li><a href="global.html#min">min</a></li><li><a href="global.html#minChars">minChars</a></li><li><a href="global.html#modalPromptCancelButtonText">modalPromptCancelButtonText</a></li><li><a href="global.html#modalPromptOkButtonText">modalPromptOkButtonText</a></li><li><a href="global.html#modalPromptTitle">modalPromptTitle</a></li><li><a href="global.html#multipleDrawing">multipleDrawing</a></li><li><a href="global.html#name">name</a></li><li><a href="global.html#nodeTitleRenderer">nodeTitleRenderer</a></li><li><a href="global.html#nominatimBaseUrl">nominatimBaseUrl</a></li><li><a href="global.html#onCancel">onCancel</a></li><li><a href="global.html#onChange">onChange</a></li><li><a href="global.html#onClick">onClick</a></li><li><a href="global.html#onDrawEnd">onDrawEnd</a></li><li><a href="global.html#onDrawStart">onDrawStart</a></li><li><a href="global.html#onError">onError</a></li><li><a href="global.html#onGeolocationChange">onGeolocationChange</a></li><li><a href="global.html#onLayerAddToMap">onLayerAddToMap</a></li><li><a href="global.html#onResize">onResize</a></li><li><a href="global.html#onResizeStart">onResizeStart</a></li><li><a href="global.html#onResizeStop">onResizeStop</a></li><li><a href="global.html#onRowClick">onRowClick</a></li><li><a href="global.html#onRowMouseOut">onRowMouseOut</a></li><li><a href="global.html#onRowMouseOver">onRowMouseOver</a></li><li><a href="global.html#onRowSelectionChange">onRowSelectionChange</a></li><li><a href="global.html#onSelect">onSelect</a></li><li><a href="global.html#onSelectionChange">onSelectionChange</a></li><li><a href="global.html#onZoomLevelSelect">onZoomLevelSelect</a></li><li><a href="global.html#orientation">orientation</a></li><li><a href="global.html#parentId">parentId</a></li><li><a href="global.html#polygon_geojson">polygon_geojson</a></li><li><a href="global.html#position">position</a></li><li><a href="global.html#predefinedCrsDefinitions">predefinedCrsDefinitions</a></li><li><a href="global.html#pressed">pressed</a></li><li><a href="global.html#pushScaleOption:Helperfunctiontocreatea%257B@linkOption%257Dscalecomponentbasedonaresolutionandthe%257B@linkOl.View%257D">pushScaleOption: Helper function to create a {@link Option} scale component
based on a resolution and the {@link Ol.View}</a></li><li><a href="global.html#radius">radius</a></li><li><a href="global.html#renderOption">renderOption</a></li><li><a href="global.html#resizeOpts">resizeOpts</a></li><li><a href="global.html#resolutions">resolutions</a></li><li><a href="global.html#rotationAngle">rotationAngle</a></li><li><a href="global.html#rowClassName">rowClassName</a></li><li><a href="global.html#scales">scales</a></li><li><a href="global.html#segmentAngles">segmentAngles</a></li><li><a href="global.html#selectable">selectable</a></li><li><a href="global.html#selectedName">selectedName</a></li><li><a href="global.html#selectFillColor">selectFillColor</a></li><li><a href="global.html#selectStrokeColor">selectStrokeColor</a></li><li><a href="global.html#selectStyle">selectStyle</a></li><li><a href="global.html#setProjection">setProjection</a></li><li><a href="global.html#showMarker">showMarker</a></li><li><a href="global.html#showMeasureInfoOnClickedPoints">showMeasureInfoOnClickedPoints</a></li><li><a href="global.html#strokeColor">strokeColor</a></li><li><a href="global.html#style">style</a></li><li><a href="global.html#syncWithMap">syncWithMap</a></li><li><a href="global.html#timeLayerAware">timeLayerAware</a></li><li><a href="global.html#title">title</a></li><li><a href="global.html#titleBarHeight">titleBarHeight</a></li><li><a href="global.html#titleText">titleText</a></li><li><a href="global.html#tools">tools</a></li><li><a href="global.html#tooltip">tooltip</a></li><li><a href="global.html#tooltipPlacement">tooltipPlacement</a></li><li><a href="global.html#trackingoptions">trackingoptions</a></li><li><a href="global.html#triggerRerenderingWithInvertedVisibility">triggerRerenderingWithInvertedVisibility</a></li><li><a href="global.html#useRange">useRange</a></li><li><a href="global.html#userMenu">userMenu</a></li><li><a href="global.html#userName">userName</a></li><li><a href="global.html#value">value</a></li><li><a href="global.html#viewbox">viewbox</a></li><li><a href="global.html#width">width</a></li><li><a href="global.html#wmsLayer">wmsLayer</a></li><li><a href="global.html#wmsLayers">wmsLayers</a></li><li><a href="global.html#zoomLevel">zoomLevel</a></li><li><a href="global.html#zoomToExtent">zoomToExtent</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on Sat Mar 24 2018 15:57:43 GMT+0000 (UTC)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
